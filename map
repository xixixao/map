#!/usr/bin/env node


// Generated by CoffeeScript 1.4.0
var args, color, colorAll, colorImportant, command, doesExist, exec, execute, executeList, fs, isBackgroundProcess, isDirectory, mapTo, mapping, numberExecuted, path, pathSplit, util;

fs = require('fs');

path = require('path');

exec = require('child_process').exec;

util = require('util');

args = process.argv;

command = args[args.length - 1];

executeList = [];

if (typeof command !== 'string') {
  return;
}

color = function(color, string) {
  return "\u001b[" + color + "m\u001b[1m" + string + "\u001b[22m\u001b[39m";
};

colorAll = function(string) {
  return color("32", string);
};

colorImportant = function(string) {
  return color("33", string);
};

pathSplit = function(filePath) {
  var baseName, dirPath, extension;
  dirPath = path.dirname(filePath);
  extension = path.extname(filePath);
  baseName = path.basename(filePath, extension);
  return [dirPath, baseName, extension];
};

mapping = function(filePath) {
  var alias, baseName, colorBaseName, colorDirAndName, colorValue, colorized, dirAndName, dirPath, extension, invalid, map, mapped, replace, split, value, _i, _len, _ref, _ref1, _ref2;
  mapped = command;
  colorized = command;
  _ref = split = pathSplit(filePath), dirPath = _ref[0], baseName = _ref[1], extension = _ref[2];
  dirAndName = path.join(dirPath, baseName);
  colorBaseName = colorImportant(baseName);
  colorDirAndName = dirAndName.replace(new RegExp("" + baseName + "$"), colorBaseName);
  map = {
    'it': [filePath, colorDirAndName + extension],
    'dir': [dirPath, dirPath],
    'name': [baseName, colorBaseName],
    'ext': [extension, extension],
    'file': [baseName + extension, colorBaseName + extension],
    'path': [dirAndName, colorDirAndName]
  };
  replace = function(string, alias, value) {
    return string.replace(new RegExp("(^|[^#])#" + alias, "g"), "$1" + value).replace(new RegExp("#(#" + alias + ")", "g"), "$1");
  };
  for (alias in map) {
    _ref1 = map[alias], value = _ref1[0], colorValue = _ref1[1];
    mapped = replace(mapped, alias, value);
    colorized = replace(colorized, alias, colorAll(colorValue));
  }
  if (!(extension != null)) {
    _ref2 = ['name', 'path', 'ext'];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      invalid = _ref2[_i];
      if (mapped.match(new RegExp("(^|[^#])#" + invalid))) {
        console.error("#" + invalid + " token used but " + (clrGreen(filePath)) + " was not found.");
        process.exit(1);
      }
    }
  }
  return [mapped, colorized];
};

doesExist = function(filePath) {
  if (fs.existsSync != null) {
    return fs.existsSync(filePath);
  } else if (path.existsSync != null) {
    return path.existsSync(filePath);
  } else {
    throw "Node.js missing either path or fs existsSync";
  }
};

isDirectory = function(filePath) {
  var fileStats, _ref;
  fileStats = fs.statSync(filePath);
  return fileStats.isDirectory() && ((_ref = filePath[filePath.length - 1]) === '/' || _ref === '\\');
};

mapTo = function(list, inside) {
  var filePath, isFile, _i, _len;
  for (_i = 0, _len = list.length; _i < _len; _i++) {
    filePath = list[_i];
    if (inside != null) {
      filePath = path.join(inside, filePath);
    }
    isFile = doesExist(filePath);
    if (isFile) {
      if (isDirectory(filePath)) {
        mapTo(fs.readdirSync(filePath), filePath);
        continue;
      }
    }
    executeList.push(mapping(filePath));
  }
};

isBackgroundProcess = function(command) {
  return command.match(/&\s*$/) != null;
};

numberExecuted = 0;

execute = function(list) {
  var colorized, isBackground, mapped, _ref;
  if (list.length === 0) {
    if (numberExecuted > 0) {
      console.log('');
    }
    return;
  }
  if (numberExecuted === 0) {
    console.log('');
  }
  _ref = list.shift(), mapped = _ref[0], colorized = _ref[1];
  console.log(colorized);
  numberExecuted++;
  isBackground = isBackgroundProcess(mapped);
  exec(mapped, function(error, stdout, stderr) {
    if (stdout.length) {
      util.print(stdout);
    }
    if (stderr.length) {
      util.error(stderr.replace(/\n$/, ''));
    }
    if (!isBackground) {
      return execute(list);
    }
  });
  if (isBackground) {
    execute(list);
  }
};

mapTo(args.slice(2, -1));

execute(executeList);
